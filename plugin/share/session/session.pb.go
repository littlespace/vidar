// Code generated by protoc-gen-go. DO NOT EDIT.
// source: session.proto

/*
Package session is a generated protocol buffer package.

It is generated from these files:
	session.proto

It has these top-level messages:
	Connect
	Project
	TableOfContents
	WindowSize
	Tabs
	Splits
	Layout
	Selections
	CursorPosition
	Request
	TextEdit
	FileEvent
	Event
*/
package session

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Splits_Direction int32

const (
	Splits_Horizontal Splits_Direction = 0
	Splits_Vertical   Splits_Direction = 1
)

var Splits_Direction_name = map[int32]string{
	0: "Horizontal",
	1: "Vertical",
}
var Splits_Direction_value = map[string]int32{
	"Horizontal": 0,
	"Vertical":   1,
}

func (x Splits_Direction) String() string {
	return proto.EnumName(Splits_Direction_name, int32(x))
}
func (Splits_Direction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type FileEvent_Op int32

const (
	FileEvent_Create FileEvent_Op = 0
	FileEvent_Write  FileEvent_Op = 1
	FileEvent_Remove FileEvent_Op = 2
	FileEvent_Rename FileEvent_Op = 3
	FileEvent_Chmod  FileEvent_Op = 4
)

var FileEvent_Op_name = map[int32]string{
	0: "Create",
	1: "Write",
	2: "Remove",
	3: "Rename",
	4: "Chmod",
}
var FileEvent_Op_value = map[string]int32{
	"Create": 0,
	"Write":  1,
	"Remove": 2,
	"Rename": 3,
	"Chmod":  4,
}

func (x FileEvent_Op) String() string {
	return proto.EnumName(FileEvent_Op_name, int32(x))
}
func (FileEvent_Op) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

type Connect struct {
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *Connect) Reset()                    { *m = Connect{} }
func (m *Connect) String() string            { return proto.CompactTextString(m) }
func (*Connect) ProtoMessage()               {}
func (*Connect) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Connect) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

type Project struct {
	Root *Project_Directory `protobuf:"bytes,1,opt,name=root" json:"root,omitempty"`
}

func (m *Project) Reset()                    { *m = Project{} }
func (m *Project) String() string            { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()               {}
func (*Project) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Project) GetRoot() *Project_Directory {
	if m != nil {
		return m.Root
	}
	return nil
}

type Project_Directory struct {
	Path     string               `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Children []*Project_Directory `protobuf:"bytes,2,rep,name=children" json:"children,omitempty"`
}

func (m *Project_Directory) Reset()                    { *m = Project_Directory{} }
func (m *Project_Directory) String() string            { return proto.CompactTextString(m) }
func (*Project_Directory) ProtoMessage()               {}
func (*Project_Directory) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *Project_Directory) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Project_Directory) GetChildren() []*Project_Directory {
	if m != nil {
		return m.Children
	}
	return nil
}

type TableOfContents struct {
	Nodes []*TableOfContents_Node `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *TableOfContents) Reset()                    { *m = TableOfContents{} }
func (m *TableOfContents) String() string            { return proto.CompactTextString(m) }
func (*TableOfContents) ProtoMessage()               {}
func (*TableOfContents) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TableOfContents) GetNodes() []*TableOfContents_Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type TableOfContents_Node struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// color is encoded as four 8 bit values (RGBA) in a 64-bit integer.
	Color    int64                   `protobuf:"varint,2,opt,name=color" json:"color,omitempty"`
	Filename string                  `protobuf:"bytes,3,opt,name=filename" json:"filename,omitempty"`
	Offset   int32                   `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
	Children []*TableOfContents_Node `protobuf:"bytes,5,rep,name=children" json:"children,omitempty"`
}

func (m *TableOfContents_Node) Reset()                    { *m = TableOfContents_Node{} }
func (m *TableOfContents_Node) String() string            { return proto.CompactTextString(m) }
func (*TableOfContents_Node) ProtoMessage()               {}
func (*TableOfContents_Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *TableOfContents_Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableOfContents_Node) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *TableOfContents_Node) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *TableOfContents_Node) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *TableOfContents_Node) GetChildren() []*TableOfContents_Node {
	if m != nil {
		return m.Children
	}
	return nil
}

type WindowSize struct {
	X uint32 `protobuf:"varint,1,opt,name=x" json:"x,omitempty"`
	Y uint32 `protobuf:"varint,2,opt,name=y" json:"y,omitempty"`
}

func (m *WindowSize) Reset()                    { *m = WindowSize{} }
func (m *WindowSize) String() string            { return proto.CompactTextString(m) }
func (*WindowSize) ProtoMessage()               {}
func (*WindowSize) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WindowSize) GetX() uint32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *WindowSize) GetY() uint32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type Tabs struct {
	OpenTabs []string `protobuf:"bytes,1,rep,name=open_tabs,json=openTabs" json:"open_tabs,omitempty"`
}

func (m *Tabs) Reset()                    { *m = Tabs{} }
func (m *Tabs) String() string            { return proto.CompactTextString(m) }
func (*Tabs) ProtoMessage()               {}
func (*Tabs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Tabs) GetOpenTabs() []string {
	if m != nil {
		return m.OpenTabs
	}
	return nil
}

type Splits struct {
	Direction Splits_Direction `protobuf:"varint,1,opt,name=direction,enum=Splits_Direction" json:"direction,omitempty"`
	Splits    []*Layout        `protobuf:"bytes,2,rep,name=splits" json:"splits,omitempty"`
}

func (m *Splits) Reset()                    { *m = Splits{} }
func (m *Splits) String() string            { return proto.CompactTextString(m) }
func (*Splits) ProtoMessage()               {}
func (*Splits) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Splits) GetDirection() Splits_Direction {
	if m != nil {
		return m.Direction
	}
	return Splits_Horizontal
}

func (m *Splits) GetSplits() []*Layout {
	if m != nil {
		return m.Splits
	}
	return nil
}

type Layout struct {
	// Types that are valid to be assigned to Children:
	//	*Layout_Tabs
	//	*Layout_Splits
	Children isLayout_Children `protobuf_oneof:"children"`
}

func (m *Layout) Reset()                    { *m = Layout{} }
func (m *Layout) String() string            { return proto.CompactTextString(m) }
func (*Layout) ProtoMessage()               {}
func (*Layout) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isLayout_Children interface {
	isLayout_Children()
}

type Layout_Tabs struct {
	Tabs *Tabs `protobuf:"bytes,1,opt,name=tabs,oneof"`
}
type Layout_Splits struct {
	Splits *Splits `protobuf:"bytes,2,opt,name=splits,oneof"`
}

func (*Layout_Tabs) isLayout_Children()   {}
func (*Layout_Splits) isLayout_Children() {}

func (m *Layout) GetChildren() isLayout_Children {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Layout) GetTabs() *Tabs {
	if x, ok := m.GetChildren().(*Layout_Tabs); ok {
		return x.Tabs
	}
	return nil
}

func (m *Layout) GetSplits() *Splits {
	if x, ok := m.GetChildren().(*Layout_Splits); ok {
		return x.Splits
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Layout) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Layout_OneofMarshaler, _Layout_OneofUnmarshaler, _Layout_OneofSizer, []interface{}{
		(*Layout_Tabs)(nil),
		(*Layout_Splits)(nil),
	}
}

func _Layout_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Layout)
	// children
	switch x := m.Children.(type) {
	case *Layout_Tabs:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tabs); err != nil {
			return err
		}
	case *Layout_Splits:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Splits); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Layout.Children has unexpected type %T", x)
	}
	return nil
}

func _Layout_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Layout)
	switch tag {
	case 1: // children.tabs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Tabs)
		err := b.DecodeMessage(msg)
		m.Children = &Layout_Tabs{msg}
		return true, err
	case 2: // children.splits
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Splits)
		err := b.DecodeMessage(msg)
		m.Children = &Layout_Splits{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Layout_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Layout)
	// children
	switch x := m.Children.(type) {
	case *Layout_Tabs:
		s := proto.Size(x.Tabs)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Layout_Splits:
		s := proto.Size(x.Splits)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Selections struct {
	Positions []*Selections_Selection `protobuf:"bytes,1,rep,name=positions" json:"positions,omitempty"`
}

func (m *Selections) Reset()                    { *m = Selections{} }
func (m *Selections) String() string            { return proto.CompactTextString(m) }
func (*Selections) ProtoMessage()               {}
func (*Selections) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Selections) GetPositions() []*Selections_Selection {
	if m != nil {
		return m.Positions
	}
	return nil
}

type Selections_Selection struct {
	Start uint32 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
}

func (m *Selections_Selection) Reset()                    { *m = Selections_Selection{} }
func (m *Selections_Selection) String() string            { return proto.CompactTextString(m) }
func (*Selections_Selection) ProtoMessage()               {}
func (*Selections_Selection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Selections_Selection) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Selections_Selection) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type CursorPosition struct {
	XPercent float32 `protobuf:"fixed32,1,opt,name=x_percent,json=xPercent" json:"x_percent,omitempty"`
	YPercent float32 `protobuf:"fixed32,2,opt,name=y_percent,json=yPercent" json:"y_percent,omitempty"`
}

func (m *CursorPosition) Reset()                    { *m = CursorPosition{} }
func (m *CursorPosition) String() string            { return proto.CompactTextString(m) }
func (*CursorPosition) ProtoMessage()               {}
func (*CursorPosition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CursorPosition) GetXPercent() float32 {
	if m != nil {
		return m.XPercent
	}
	return 0
}

func (m *CursorPosition) GetYPercent() float32 {
	if m != nil {
		return m.YPercent
	}
	return 0
}

type Request struct {
	// Types that are valid to be assigned to Type:
	//	*Request_Project
	//	*Request_Toc
	//	*Request_WindowSize
	//	*Request_Cursor
	//	*Request_Selections
	//	*Request_Layout
	Type isRequest_Type `protobuf_oneof:"type"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isRequest_Type interface {
	isRequest_Type()
}

type Request_Project struct {
	Project *Project `protobuf:"bytes,1,opt,name=project,oneof"`
}
type Request_Toc struct {
	Toc *TableOfContents `protobuf:"bytes,2,opt,name=toc,oneof"`
}
type Request_WindowSize struct {
	WindowSize *WindowSize `protobuf:"bytes,3,opt,name=windowSize,oneof"`
}
type Request_Cursor struct {
	Cursor *CursorPosition `protobuf:"bytes,4,opt,name=cursor,oneof"`
}
type Request_Selections struct {
	Selections *Selections `protobuf:"bytes,6,opt,name=selections,oneof"`
}
type Request_Layout struct {
	Layout *Layout `protobuf:"bytes,7,opt,name=layout,oneof"`
}

func (*Request_Project) isRequest_Type()    {}
func (*Request_Toc) isRequest_Type()        {}
func (*Request_WindowSize) isRequest_Type() {}
func (*Request_Cursor) isRequest_Type()     {}
func (*Request_Selections) isRequest_Type() {}
func (*Request_Layout) isRequest_Type()     {}

func (m *Request) GetType() isRequest_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Request) GetProject() *Project {
	if x, ok := m.GetType().(*Request_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Request) GetToc() *TableOfContents {
	if x, ok := m.GetType().(*Request_Toc); ok {
		return x.Toc
	}
	return nil
}

func (m *Request) GetWindowSize() *WindowSize {
	if x, ok := m.GetType().(*Request_WindowSize); ok {
		return x.WindowSize
	}
	return nil
}

func (m *Request) GetCursor() *CursorPosition {
	if x, ok := m.GetType().(*Request_Cursor); ok {
		return x.Cursor
	}
	return nil
}

func (m *Request) GetSelections() *Selections {
	if x, ok := m.GetType().(*Request_Selections); ok {
		return x.Selections
	}
	return nil
}

func (m *Request) GetLayout() *Layout {
	if x, ok := m.GetType().(*Request_Layout); ok {
		return x.Layout
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Request) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Request_OneofMarshaler, _Request_OneofUnmarshaler, _Request_OneofSizer, []interface{}{
		(*Request_Project)(nil),
		(*Request_Toc)(nil),
		(*Request_WindowSize)(nil),
		(*Request_Cursor)(nil),
		(*Request_Selections)(nil),
		(*Request_Layout)(nil),
	}
}

func _Request_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Request)
	// type
	switch x := m.Type.(type) {
	case *Request_Project:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Project); err != nil {
			return err
		}
	case *Request_Toc:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Toc); err != nil {
			return err
		}
	case *Request_WindowSize:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WindowSize); err != nil {
			return err
		}
	case *Request_Cursor:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cursor); err != nil {
			return err
		}
	case *Request_Selections:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Selections); err != nil {
			return err
		}
	case *Request_Layout:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Layout); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Request.Type has unexpected type %T", x)
	}
	return nil
}

func _Request_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Request)
	switch tag {
	case 1: // type.project
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Project)
		err := b.DecodeMessage(msg)
		m.Type = &Request_Project{msg}
		return true, err
	case 2: // type.toc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TableOfContents)
		err := b.DecodeMessage(msg)
		m.Type = &Request_Toc{msg}
		return true, err
	case 3: // type.windowSize
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WindowSize)
		err := b.DecodeMessage(msg)
		m.Type = &Request_WindowSize{msg}
		return true, err
	case 4: // type.cursor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CursorPosition)
		err := b.DecodeMessage(msg)
		m.Type = &Request_Cursor{msg}
		return true, err
	case 6: // type.selections
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Selections)
		err := b.DecodeMessage(msg)
		m.Type = &Request_Selections{msg}
		return true, err
	case 7: // type.layout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Layout)
		err := b.DecodeMessage(msg)
		m.Type = &Request_Layout{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Request_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Request)
	// type
	switch x := m.Type.(type) {
	case *Request_Project:
		s := proto.Size(x.Project)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Request_Toc:
		s := proto.Size(x.Toc)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Request_WindowSize:
		s := proto.Size(x.WindowSize)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Request_Cursor:
		s := proto.Size(x.Cursor)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Request_Selections:
		s := proto.Size(x.Selections)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Request_Layout:
		s := proto.Size(x.Layout)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TextEdit struct {
	Offset uint32 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Old    string `protobuf:"bytes,2,opt,name=old" json:"old,omitempty"`
	New    string `protobuf:"bytes,3,opt,name=new" json:"new,omitempty"`
}

func (m *TextEdit) Reset()                    { *m = TextEdit{} }
func (m *TextEdit) String() string            { return proto.CompactTextString(m) }
func (*TextEdit) ProtoMessage()               {}
func (*TextEdit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *TextEdit) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *TextEdit) GetOld() string {
	if m != nil {
		return m.Old
	}
	return ""
}

func (m *TextEdit) GetNew() string {
	if m != nil {
		return m.New
	}
	return ""
}

type FileEvent struct {
	Path string       `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Op   FileEvent_Op `protobuf:"varint,2,opt,name=op,enum=FileEvent_Op" json:"op,omitempty"`
}

func (m *FileEvent) Reset()                    { *m = FileEvent{} }
func (m *FileEvent) String() string            { return proto.CompactTextString(m) }
func (*FileEvent) ProtoMessage()               {}
func (*FileEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *FileEvent) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileEvent) GetOp() FileEvent_Op {
	if m != nil {
		return m.Op
	}
	return FileEvent_Create
}

type Event struct {
	FocusedFile string `protobuf:"bytes,1,opt,name=focused_file,json=focusedFile" json:"focused_file,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Event_TextEdit
	//	*Event_SelectionsChanged
	//	*Event_CursorMoved
	//	*Event_FileEvent
	//	*Event_Connect
	//	*Event_Request
	//	*Event_Project
	//	*Event_Toc
	Event isEvent_Event `protobuf_oneof:"event"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type isEvent_Event interface {
	isEvent_Event()
}

type Event_TextEdit struct {
	TextEdit *TextEdit `protobuf:"bytes,2,opt,name=text_edit,json=textEdit,oneof"`
}
type Event_SelectionsChanged struct {
	SelectionsChanged *Selections `protobuf:"bytes,3,opt,name=selections_changed,json=selectionsChanged,oneof"`
}
type Event_CursorMoved struct {
	CursorMoved *CursorPosition `protobuf:"bytes,4,opt,name=cursor_moved,json=cursorMoved,oneof"`
}
type Event_FileEvent struct {
	FileEvent *FileEvent `protobuf:"bytes,5,opt,name=file_event,json=fileEvent,oneof"`
}
type Event_Connect struct {
	Connect *Connect `protobuf:"bytes,18,opt,name=connect,oneof"`
}
type Event_Request struct {
	Request *Request `protobuf:"bytes,19,opt,name=request,oneof"`
}
type Event_Project struct {
	Project *Project `protobuf:"bytes,16,opt,name=project,oneof"`
}
type Event_Toc struct {
	Toc *TableOfContents `protobuf:"bytes,21,opt,name=toc,oneof"`
}

func (*Event_TextEdit) isEvent_Event()          {}
func (*Event_SelectionsChanged) isEvent_Event() {}
func (*Event_CursorMoved) isEvent_Event()       {}
func (*Event_FileEvent) isEvent_Event()         {}
func (*Event_Connect) isEvent_Event()           {}
func (*Event_Request) isEvent_Event()           {}
func (*Event_Project) isEvent_Event()           {}
func (*Event_Toc) isEvent_Event()               {}

func (m *Event) GetEvent() isEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Event) GetFocusedFile() string {
	if m != nil {
		return m.FocusedFile
	}
	return ""
}

func (m *Event) GetTextEdit() *TextEdit {
	if x, ok := m.GetEvent().(*Event_TextEdit); ok {
		return x.TextEdit
	}
	return nil
}

func (m *Event) GetSelectionsChanged() *Selections {
	if x, ok := m.GetEvent().(*Event_SelectionsChanged); ok {
		return x.SelectionsChanged
	}
	return nil
}

func (m *Event) GetCursorMoved() *CursorPosition {
	if x, ok := m.GetEvent().(*Event_CursorMoved); ok {
		return x.CursorMoved
	}
	return nil
}

func (m *Event) GetFileEvent() *FileEvent {
	if x, ok := m.GetEvent().(*Event_FileEvent); ok {
		return x.FileEvent
	}
	return nil
}

func (m *Event) GetConnect() *Connect {
	if x, ok := m.GetEvent().(*Event_Connect); ok {
		return x.Connect
	}
	return nil
}

func (m *Event) GetRequest() *Request {
	if x, ok := m.GetEvent().(*Event_Request); ok {
		return x.Request
	}
	return nil
}

func (m *Event) GetProject() *Project {
	if x, ok := m.GetEvent().(*Event_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Event) GetToc() *TableOfContents {
	if x, ok := m.GetEvent().(*Event_Toc); ok {
		return x.Toc
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Event) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Event_OneofMarshaler, _Event_OneofUnmarshaler, _Event_OneofSizer, []interface{}{
		(*Event_TextEdit)(nil),
		(*Event_SelectionsChanged)(nil),
		(*Event_CursorMoved)(nil),
		(*Event_FileEvent)(nil),
		(*Event_Connect)(nil),
		(*Event_Request)(nil),
		(*Event_Project)(nil),
		(*Event_Toc)(nil),
	}
}

func _Event_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Event)
	// event
	switch x := m.Event.(type) {
	case *Event_TextEdit:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TextEdit); err != nil {
			return err
		}
	case *Event_SelectionsChanged:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SelectionsChanged); err != nil {
			return err
		}
	case *Event_CursorMoved:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CursorMoved); err != nil {
			return err
		}
	case *Event_FileEvent:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileEvent); err != nil {
			return err
		}
	case *Event_Connect:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Connect); err != nil {
			return err
		}
	case *Event_Request:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Request); err != nil {
			return err
		}
	case *Event_Project:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Project); err != nil {
			return err
		}
	case *Event_Toc:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Toc); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Event.Event has unexpected type %T", x)
	}
	return nil
}

func _Event_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Event)
	switch tag {
	case 2: // event.text_edit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextEdit)
		err := b.DecodeMessage(msg)
		m.Event = &Event_TextEdit{msg}
		return true, err
	case 3: // event.selections_changed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Selections)
		err := b.DecodeMessage(msg)
		m.Event = &Event_SelectionsChanged{msg}
		return true, err
	case 4: // event.cursor_moved
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CursorPosition)
		err := b.DecodeMessage(msg)
		m.Event = &Event_CursorMoved{msg}
		return true, err
	case 5: // event.file_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileEvent)
		err := b.DecodeMessage(msg)
		m.Event = &Event_FileEvent{msg}
		return true, err
	case 18: // event.connect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Connect)
		err := b.DecodeMessage(msg)
		m.Event = &Event_Connect{msg}
		return true, err
	case 19: // event.request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Request)
		err := b.DecodeMessage(msg)
		m.Event = &Event_Request{msg}
		return true, err
	case 16: // event.project
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Project)
		err := b.DecodeMessage(msg)
		m.Event = &Event_Project{msg}
		return true, err
	case 21: // event.toc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TableOfContents)
		err := b.DecodeMessage(msg)
		m.Event = &Event_Toc{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Event_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Event)
	// event
	switch x := m.Event.(type) {
	case *Event_TextEdit:
		s := proto.Size(x.TextEdit)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_SelectionsChanged:
		s := proto.Size(x.SelectionsChanged)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_CursorMoved:
		s := proto.Size(x.CursorMoved)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_FileEvent:
		s := proto.Size(x.FileEvent)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Connect:
		s := proto.Size(x.Connect)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Request:
		s := proto.Size(x.Request)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Project:
		s := proto.Size(x.Project)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Event_Toc:
		s := proto.Size(x.Toc)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Connect)(nil), "Connect")
	proto.RegisterType((*Project)(nil), "Project")
	proto.RegisterType((*Project_Directory)(nil), "Project.Directory")
	proto.RegisterType((*TableOfContents)(nil), "TableOfContents")
	proto.RegisterType((*TableOfContents_Node)(nil), "TableOfContents.Node")
	proto.RegisterType((*WindowSize)(nil), "WindowSize")
	proto.RegisterType((*Tabs)(nil), "Tabs")
	proto.RegisterType((*Splits)(nil), "Splits")
	proto.RegisterType((*Layout)(nil), "Layout")
	proto.RegisterType((*Selections)(nil), "Selections")
	proto.RegisterType((*Selections_Selection)(nil), "Selections.Selection")
	proto.RegisterType((*CursorPosition)(nil), "CursorPosition")
	proto.RegisterType((*Request)(nil), "Request")
	proto.RegisterType((*TextEdit)(nil), "TextEdit")
	proto.RegisterType((*FileEvent)(nil), "FileEvent")
	proto.RegisterType((*Event)(nil), "Event")
	proto.RegisterEnum("Splits_Direction", Splits_Direction_name, Splits_Direction_value)
	proto.RegisterEnum("FileEvent_Op", FileEvent_Op_name, FileEvent_Op_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SharedSession service

type SharedSessionClient interface {
	Start(ctx context.Context, opts ...grpc.CallOption) (SharedSession_StartClient, error)
}

type sharedSessionClient struct {
	cc *grpc.ClientConn
}

func NewSharedSessionClient(cc *grpc.ClientConn) SharedSessionClient {
	return &sharedSessionClient{cc}
}

func (c *sharedSessionClient) Start(ctx context.Context, opts ...grpc.CallOption) (SharedSession_StartClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SharedSession_serviceDesc.Streams[0], c.cc, "/SharedSession/Start", opts...)
	if err != nil {
		return nil, err
	}
	x := &sharedSessionStartClient{stream}
	return x, nil
}

type SharedSession_StartClient interface {
	Send(*Event) error
	Recv() (*Event, error)
	grpc.ClientStream
}

type sharedSessionStartClient struct {
	grpc.ClientStream
}

func (x *sharedSessionStartClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sharedSessionStartClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SharedSession service

type SharedSessionServer interface {
	Start(SharedSession_StartServer) error
}

func RegisterSharedSessionServer(s *grpc.Server, srv SharedSessionServer) {
	s.RegisterService(&_SharedSession_serviceDesc, srv)
}

func _SharedSession_Start_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SharedSessionServer).Start(&sharedSessionStartServer{stream})
}

type SharedSession_StartServer interface {
	Send(*Event) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type sharedSessionStartServer struct {
	grpc.ServerStream
}

func (x *sharedSessionStartServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sharedSessionStartServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SharedSession_serviceDesc = grpc.ServiceDesc{
	ServiceName: "SharedSession",
	HandlerType: (*SharedSessionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Start",
			Handler:       _SharedSession_Start_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "session.proto",
}

func init() { proto.RegisterFile("session.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 903 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0x51, 0x8f, 0xdb, 0x44,
	0x10, 0xb6, 0x9d, 0xd8, 0x8e, 0x27, 0x97, 0xab, 0xbb, 0x50, 0x64, 0xa5, 0xaa, 0xb8, 0xba, 0x27,
	0x94, 0xaa, 0xc2, 0x40, 0x8e, 0x47, 0xc4, 0xc3, 0x85, 0x56, 0x11, 0x02, 0xee, 0xb4, 0x39, 0xd1,
	0xc7, 0xc8, 0x67, 0x6f, 0x88, 0x91, 0xcf, 0x6b, 0xd6, 0x7b, 0x77, 0x49, 0x1f, 0x78, 0x40, 0xe2,
	0x81, 0x3f, 0x00, 0x7f, 0x8d, 0x9f, 0x83, 0x66, 0x77, 0x6d, 0x5f, 0x0b, 0x3d, 0x9e, 0xb2, 0x33,
	0xf3, 0x65, 0x76, 0xe6, 0xfb, 0x66, 0xbc, 0x30, 0x69, 0x58, 0xd3, 0x14, 0xbc, 0x4a, 0x6a, 0xc1,
	0x25, 0x8f, 0x9f, 0x81, 0xbf, 0xe0, 0x55, 0xc5, 0x32, 0x49, 0x22, 0xf0, 0x4d, 0x2c, 0xb2, 0x8f,
	0xec, 0x59, 0x40, 0x5b, 0x33, 0xfe, 0xcd, 0x06, 0xff, 0x5c, 0xf0, 0x9f, 0x11, 0xf5, 0x09, 0x0c,
	0x05, 0xe7, 0x52, 0x41, 0xc6, 0x73, 0x92, 0x18, 0x7f, 0xf2, 0x4d, 0x21, 0x58, 0x26, 0xb9, 0xd8,
	0x53, 0x15, 0x9f, 0x9e, 0x41, 0xd0, 0xb9, 0x08, 0x81, 0x61, 0x9d, 0xca, 0xad, 0xc9, 0xab, 0xce,
	0x24, 0x81, 0x51, 0xb6, 0x2d, 0xca, 0x5c, 0xb0, 0x2a, 0x72, 0x8e, 0x06, 0xef, 0x49, 0xd6, 0x61,
	0xe2, 0xbf, 0x6d, 0x78, 0x70, 0x91, 0x5e, 0x96, 0xec, 0x6c, 0xb3, 0xe0, 0x95, 0x64, 0x95, 0x6c,
	0xc8, 0x0b, 0x70, 0x2b, 0x9e, 0xb3, 0x26, 0xb2, 0x55, 0x82, 0x47, 0xc9, 0x3b, 0x80, 0xe4, 0x07,
	0x9e, 0x33, 0xaa, 0x31, 0xd3, 0xbf, 0x6c, 0x18, 0xa2, 0x8d, 0xd5, 0x54, 0xe9, 0x15, 0x6b, 0xab,
	0xc1, 0x33, 0xf9, 0x10, 0xdc, 0x8c, 0x97, 0x5c, 0x44, 0xce, 0x91, 0x3d, 0x1b, 0x50, 0x6d, 0x90,
	0x29, 0x8c, 0x36, 0x45, 0xc9, 0x14, 0x7a, 0xa0, 0xd0, 0x9d, 0x4d, 0x3e, 0x02, 0x8f, 0x6f, 0x36,
	0x0d, 0x93, 0xd1, 0xf0, 0xc8, 0x9e, 0xb9, 0xd4, 0x58, 0xe4, 0x8b, 0x3b, 0x7d, 0xb9, 0xf7, 0x95,
	0xd5, 0xb7, 0x36, 0x03, 0x78, 0x5d, 0x54, 0x39, 0xbf, 0x5d, 0x15, 0x6f, 0x18, 0x39, 0x00, 0x7b,
	0xa7, 0x6a, 0x9b, 0x50, 0x7b, 0x87, 0xd6, 0x5e, 0x15, 0x35, 0xa1, 0xf6, 0x3e, 0x7e, 0x06, 0xc3,
	0x8b, 0xf4, 0xb2, 0x21, 0x8f, 0x21, 0xe0, 0x35, 0xab, 0xd6, 0x32, 0xbd, 0xd4, 0xcd, 0x07, 0x74,
	0x84, 0x0e, 0x0c, 0xc6, 0xbf, 0xdb, 0xe0, 0xad, 0xea, 0xb2, 0x90, 0x0d, 0xf9, 0x0c, 0x82, 0x5c,
	0x71, 0xd9, 0xaa, 0x7a, 0x38, 0x7f, 0x98, 0xe8, 0x98, 0x21, 0xb9, 0xe0, 0x15, 0xed, 0x31, 0xe4,
	0x63, 0xf0, 0x1a, 0x15, 0x36, 0x9a, 0xf8, 0xc9, 0x77, 0xe9, 0x9e, 0x5f, 0x4b, 0x6a, 0xdc, 0xf1,
	0xf3, 0x56, 0x57, 0x44, 0x1f, 0x02, 0x2c, 0xb9, 0x28, 0xde, 0xf0, 0x4a, 0xa6, 0x65, 0x68, 0x91,
	0x03, 0x18, 0xfd, 0xc8, 0x84, 0x2c, 0xb2, 0xb4, 0x0c, 0xed, 0xf8, 0x02, 0x3c, 0xfd, 0x67, 0xf2,
	0x18, 0x86, 0xa6, 0x52, 0x1c, 0x1a, 0x17, 0xf9, 0x68, 0x96, 0x16, 0x55, 0x4e, 0xf2, 0xf4, 0xce,
	0x95, 0xb6, 0xba, 0x52, 0x17, 0xb8, 0xb4, 0xda, 0x4b, 0x4f, 0xa1, 0xe7, 0x34, 0xbe, 0x01, 0x58,
	0xb1, 0x52, 0x17, 0xd0, 0x90, 0x13, 0x08, 0x6a, 0xde, 0x14, 0xca, 0xe8, 0xa6, 0xa0, 0x8f, 0xf7,
	0x47, 0xda, 0xe3, 0xa6, 0x27, 0x10, 0x74, 0x7e, 0x54, 0xbe, 0x91, 0xa9, 0x90, 0x86, 0x72, 0x6d,
	0x90, 0x10, 0x06, 0xac, 0xca, 0x0d, 0xf1, 0x78, 0x8c, 0xbf, 0x85, 0xc3, 0xc5, 0xb5, 0x68, 0xb8,
	0x38, 0x37, 0x79, 0x50, 0x84, 0xdd, 0xba, 0x66, 0x22, 0x63, 0x95, 0xfe, 0xb7, 0x43, 0x47, 0xbb,
	0x73, 0x6d, 0x63, 0x70, 0xdf, 0x05, 0x1d, 0x1d, 0xdc, 0x9b, 0x60, 0xfc, 0x87, 0x03, 0x3e, 0x65,
	0xbf, 0x5c, 0xb3, 0x46, 0x92, 0x63, 0xf0, 0x6b, 0x3d, 0xf6, 0x86, 0x9e, 0x51, 0xbb, 0x06, 0x4b,
	0x8b, 0xb6, 0x21, 0x72, 0x0c, 0x03, 0xc9, 0x33, 0xc3, 0x50, 0xf8, 0xee, 0x40, 0x2d, 0x2d, 0x8a,
	0x61, 0xf2, 0x29, 0xc0, 0x6d, 0x37, 0x48, 0x6a, 0x62, 0xc7, 0xf3, 0x71, 0xd2, 0xcf, 0xd6, 0xd2,
	0xa2, 0x77, 0x00, 0xe4, 0x39, 0x78, 0x99, 0x6a, 0x49, 0x8d, 0xf0, 0x78, 0xfe, 0x20, 0x79, 0xbb,
	0x43, 0x54, 0x40, 0x03, 0x30, 0x73, 0xd3, 0xb1, 0x1a, 0x79, 0x26, 0x73, 0x4f, 0x34, 0x66, 0xee,
	0x01, 0xa8, 0x69, 0xa9, 0xa4, 0x8f, 0x7c, 0xa3, 0xa9, 0x9e, 0x04, 0xcc, 0xa8, 0x03, 0xa7, 0x1e,
	0x0c, 0xe5, 0xbe, 0x66, 0xf1, 0x2b, 0x18, 0x5d, 0xb0, 0x9d, 0x7c, 0x99, 0x17, 0xf2, 0xce, 0x4e,
	0x69, 0x31, 0xda, 0x9d, 0x0a, 0x61, 0xc0, 0x4b, 0xad, 0x46, 0x40, 0xf1, 0x88, 0x9e, 0x8a, 0xdd,
	0x9a, 0xa5, 0xc4, 0x63, 0xfc, 0x2b, 0x04, 0xaf, 0x8a, 0x92, 0xbd, 0xbc, 0x41, 0xf6, 0xff, 0xeb,
	0x83, 0xf3, 0x04, 0x1c, 0x5e, 0xab, 0x1c, 0x87, 0xf3, 0x49, 0xd2, 0x61, 0x93, 0xb3, 0x9a, 0x3a,
	0xbc, 0x8e, 0xbf, 0x06, 0xe7, 0xac, 0x26, 0x00, 0xde, 0x42, 0xb0, 0x54, 0xb2, 0xd0, 0x22, 0x01,
	0xb8, 0xaf, 0x45, 0x21, 0x59, 0x68, 0xa3, 0x9b, 0xb2, 0x2b, 0x7e, 0xc3, 0x42, 0x47, 0x9f, 0xf1,
	0x13, 0x10, 0x0e, 0x10, 0xb2, 0xd8, 0x5e, 0xf1, 0x3c, 0x1c, 0xc6, 0x7f, 0x0e, 0xc0, 0xd5, 0x97,
	0x3f, 0x85, 0x83, 0x0d, 0xcf, 0xae, 0x1b, 0x96, 0xaf, 0xf1, 0x6b, 0x61, 0x8a, 0x18, 0x1b, 0x1f,
	0x5e, 0x4c, 0x66, 0x10, 0x48, 0xb6, 0x93, 0x6b, 0x96, 0x17, 0xd2, 0x88, 0x1a, 0x24, 0x2d, 0x0d,
	0x4b, 0x8b, 0x8e, 0x64, 0x4b, 0xc9, 0x57, 0x40, 0x7a, 0x5e, 0xd7, 0xd9, 0x36, 0xad, 0x7e, 0x62,
	0x79, 0x27, 0xed, 0x5b, 0x02, 0x3c, 0xec, 0x81, 0x0b, 0x8d, 0x23, 0x5f, 0xc2, 0x81, 0x16, 0x70,
	0x8d, 0xc5, 0xe7, 0xef, 0xd7, 0x79, 0xac, 0x61, 0xdf, 0x23, 0x8a, 0xbc, 0x00, 0xc0, 0xc2, 0xd7,
	0x0c, 0xdb, 0x89, 0x5c, 0xf5, 0x1f, 0xe8, 0x19, 0x5b, 0x5a, 0x34, 0xd8, 0x74, 0x54, 0x1f, 0x83,
	0x9f, 0xe9, 0x17, 0x24, 0x22, 0x66, 0x7e, 0xcd, 0x8b, 0x82, 0xf3, 0x6b, 0x42, 0x88, 0x12, 0x7a,
	0xe0, 0xa3, 0x0f, 0x0c, 0xca, 0x2c, 0x00, 0xa2, 0xc4, 0xbf, 0x77, 0x21, 0xfc, 0xdf, 0x5d, 0x78,
	0x74, 0xef, 0x2e, 0x9c, 0xfa, 0xe0, 0xaa, 0xfa, 0xe7, 0x09, 0x4c, 0x56, 0xdb, 0x54, 0xb0, 0x7c,
	0xa5, 0x9f, 0x33, 0xf2, 0x04, 0xdc, 0x95, 0x5a, 0x72, 0x2f, 0x51, 0x2d, 0x4c, 0xcd, 0x6f, 0x6c,
	0xcd, 0xec, 0xcf, 0xed, 0x4b, 0x4f, 0xbd, 0x8c, 0x27, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x5a,
	0x78, 0x38, 0xd3, 0x2a, 0x07, 0x00, 0x00,
}
